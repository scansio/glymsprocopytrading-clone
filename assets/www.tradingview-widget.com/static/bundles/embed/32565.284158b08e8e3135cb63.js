"use strict";(self.webpackChunktradingview=self.webpackChunktradingview||[]).push([[32565],{584785:(t,e,i)=>{var s;i.d(e,{PlotRowSearchMode:()=>s}),function(t){t[t.NearestLeft=-1]="NearestLeft",t[t.Exact=0]="Exact",t[t.NearestRight=1]="NearestRight"}(s||(s={}))},132565:(t,e,i)=>{i.d(e,{PlotList:()=>u,mergeMinMax:()=>c});var s=i(650151),n=i(660439),r=i(707771),a=i(735566),h=i(584785);const l=(0,a.getLogger)("Chart.PlotList"),o=30;function _(t){return t.index}function d(t){return t.value[0]}class u{constructor(t=null,e=null){this._items=[],this._start=0,this._end=0,this._shareRead=!1,this._minMaxCache=new Map,this._rowSearchCacheByIndex=new Map,this._rowSearchCacheByIndexWithoutEmptyValues=new Map,this._rowSearchCacheByTime=new Map,this._rowSearchCacheByTimeWithoutEmptyValues=new Map,this._plotFunctions=t||new Map,this._emptyValuePredicate=e}clear(){this._items=[],this._start=0,this._end=0,this._shareRead=!1,this._minMaxCache.clear(),this._invalidateSearchCaches()}first(){return this.size()>0?this._items[this._start]:null}last(){return this.size()>0?this._items[this._end-1]:null}firstIndex(){return this.size()>0?this._indexAt(this._start):null}firstPlottableIndex(){if(this.isEmpty())return null;for(let t=this._start;t<this._end;++t){const e=this._indexAt(t);if(e>r.UNPLOTTABLE_TIME_POINT_INDEX)return e}return null}lastIndex(){return this.size()>0?this._indexAt(this._end-1):null}clone(){const t=this.firstIndex(),e=this.lastIndex();return null===t||null===e?new u:this.range(t,e)}size(){return this._end-this._start}isEmpty(){return 0===this.size()}contains(t){return null!==this.search(t,h.PlotRowSearchMode.Exact)}valueAt(t){const e=this.search(t);return null!==e?e.value:null}add(t,e){if(this._shareRead)return l.logDebug("add: readonly collection modification attempt"),!1;const i={index:t,value:e},s=this._nonCachedSearch(t,h.PlotRowSearchMode.Exact,_);return this._invalidateSearchCaches(),null===s?(this._items.splice(this._lowerbound(t,_),0,i),this._start=0,this._end=this._items.length,!0):(this._items[s]=i,!1)}search(t,e=h.PlotRowSearchMode.Exact,i){return this._searchImpl(t,e,this._rowSearchCacheByIndex,this._rowSearchCacheByIndexWithoutEmptyValues,_,i)}searchByTime(t,e=h.PlotRowSearchMode.Exact,i){return this._searchImpl(t,e,this._rowSearchCacheByTime,this._rowSearchCacheByTimeWithoutEmptyValues,d,i)}fold(t,e){let i=e;for(let e=this._start;e<this._end;++e){i=t(this._indexAt(e),this._valueAt(e),i)}return i}findFirst(t,e){const i=void 0!==e&&Math.min(this._start+e,this._end)||this._end;for(let e=this._start;e<i;++e){const i=this._indexAt(e),s=this._valueAt(e);if(t(i,s))return{index:i,value:s}}return null}findLast(t,e){const i=void 0!==e&&Math.max(this._end-e,this._start)||this._start;for(let e=this._end-1;e>=i;--e){const i=this._indexAt(e),s=this._valueAt(e);if(t(i,s))return{index:i,value:s}}return null}each(t){for(let e=this._start;e<this._end;++e){if(t(this._indexAt(e),this._valueAt(e)))break}}reduce(t,e){let i=e;for(let e=this._start;e<this._end;++e){i=t(i,this._indexAt(e),this._valueAt(e))}return i}range(t,e){
const i=new u(this._plotFunctions,this._emptyValuePredicate);return i._items=this._items,i._start=this._lowerbound(t,_),i._end=this._upperbound(e),i._shareRead=!0,i}plottableRange(t){const e=new u(this._plotFunctions,this._emptyValuePredicate);return e._items=this._items,e._start=this._upperbound(r.UNPLOTTABLE_TIME_POINT_INDEX),e._end=this._end,e._shareRead=!0,!0===t&&e._start>this._start&&(e._start-=1),e}rangeCountback(t,e){if(null===this.firstIndex())return new u;const i=new u(this._plotFunctions,this._emptyValuePredicate);return i._items=this._items,i._end=this._upperbound(t),i._start=Math.max(this._start,i._end-e),i._shareRead=!0,i}rangeIterator(t,e){const i=this._lowerbound(t,_),s=this._upperbound(e);return this._rangeIteratorImpl(i,s)}fullRangeIterator(){return this._rangeIteratorImpl(this._start,this._end)}minMaxOnRangeCached(t,e,i){if(this.isEmpty())return null;let s=null;for(const n of i){s=c(s,this._minMaxOnRangeCachedImpl(t-n.offset,e-n.offset,n.name))}return s}minMaxOnRange(t,e,i){if(this.isEmpty())return null;let s=null;for(const n of i){s=c(s,this._minMaxOnRange(t-n.offset,e-n.offset,n.name))}return s}merge(t){return this._shareRead?(l.logDebug("merge: readonly collection modification attempt"),null):0===t.length?null:this.isEmpty()||t[t.length-1].index<this._items[0].index?this._prepend(t):t[0].index>this._items[this._items.length-1].index?this._append(t):1===t.length&&t[0].index===this._items[this._items.length-1].index?(this._updateLast(t[0]),t[0]):this._merge(t)}addTail(t,e=!1){if(0===t.length)return;let i=0;e&&this._end-this._start>0&&(i=1,this._items[this._end-this._start-1].value=t[0].value);for(let e=i;e<t.length;++e){const i=t[e],s=this.lastIndex();if(null===s){l.logError("Can't add tail to the empty plotlist");break}this.add(s+1,i.value)}this._invalidateSearchCaches()}move(t){if(this._shareRead)return void l.logDebug("move: readonly collection modification attempt");if(0===t.length)return;const e=this._items.slice();for(const i of t){const t=this._bsearch(i.old,_);if(null!==t&&void 0!==e[t])if(i.new===r.INVALID_TIME_POINT_INDEX)e[t]=void 0;else{e[t]={index:i.new,value:e[t].value};const s=this._bsearch(i.new,_);if(null!==s){const t=e[s];void 0!==t&&t.index===i.new&&(e[s]=void 0)}}}this._items=e.filter((t=>void 0!==t)).sort(((t,e)=>t.index-e.index)),this._invalidateSearchCaches(),this._minMaxCache.clear(),this._start=0,this._end=this._items.length}remove(t){if(this._shareRead)return l.logDebug("remove: readonly collection modification attempt"),null;const e=this._nonCachedSearch(t,h.PlotRowSearchMode.NearestRight,_);if(null===e)return null;const i=this._items.splice(e);return this._end=this._items.length,this._minMaxCache.clear(),this._invalidateSearchCaches(),i.length>0?i[0]:null}state(){const t=this._items.slice(this._start,this._end);return{start:0,end:t.length,data:t}}restoreState(t){t?(this._start=t.start,this._end=t.end,this._shareRead=!1,this._items=t.data,this._minMaxCache.clear(),this._invalidateSearchCaches()):this.clear()}_indexAt(t){return this._items[t].index}_valueAt(t){
return this._items[t].value}_length(){return this._items.length}_searchImpl(t,e,i,s,n,r){const a=void 0!==r?i:s,h=void 0!==r?1e4*(e+1)+r:e;let l=a.get(t);if(void 0!==l){const t=l.get(h);if(void 0!==t)return t}const o=this._nonCachedSearch(t,e,n,r);if(null===o)return null;const _={index:this._indexAt(o),value:this._valueAt(o)};return void 0===l&&(l=new Map,a.set(t,l)),l.set(h,_),_}_nonCachedSearch(t,e,i,s){const n=this._lowerbound(t,i),r=n===this._end||t!==i(this._items[n]);if(r&&e!==h.PlotRowSearchMode.Exact)switch(e){case h.PlotRowSearchMode.NearestLeft:return this._searchNearestLeft(n,s);case h.PlotRowSearchMode.NearestRight:return this._searchNearestRight(n,s);default:throw new TypeError("Unknown search mode")}if(void 0===s||r||e===h.PlotRowSearchMode.Exact)return r?null:n;switch(e){case h.PlotRowSearchMode.NearestLeft:return this._nonEmptyNearestLeft(n,s);case h.PlotRowSearchMode.NearestRight:return this._nonEmptyNearestRight(n,s);default:throw new TypeError("Unknown search mode")}}_nonEmptyNearestRight(t,e){const i=(0,s.ensure)(this._emptyValuePredicate),n=(0,s.ensure)(e);for(;t<this._end&&i(this._valueAt(t),n);)t+=1;return t===this._end?null:t}_nonEmptyNearestLeft(t,e){const i=(0,s.ensureNotNull)(this._emptyValuePredicate),n=(0,s.ensure)(e);for(;t>=this._start&&i(this._valueAt(t),n);)t-=1;return t<this._start?null:t}_searchNearestLeft(t,e){if(t===this._start)return null;const i=t-1,s=i!==this._end?i:null;return void 0!==e&&null!==s?this._nonEmptyNearestLeft(s,e):s}_searchNearestRight(t,e){const i=t,s=i!==this._end?i:null;return void 0!==e&&null!==s?this._nonEmptyNearestRight(s,e):s}_bsearch(t,e){const i=this._lowerbound(t,e);return i!==this._end&&t===e(this._items[i])?i:null}_lowerbound(t,e){return(0,n.lowerbound)(this._items,t,((t,i)=>e(t)<i),this._start,this._end)}_upperbound(t){return(0,n.upperbound)(this._items,t,((t,e)=>e.index>t),this._start,this._end)}_plotMinMax(t,e,i){let s=null;const n=this._plotFunctions.get(i);if(void 0===n)throw new Error(`Plot "${i}" is not registered`);for(let i=t;i<e;i++){const t=n(this._items[i].value);null==t||Number.isNaN(t)||(null===s?s={min:t,max:t}:(t<s.min&&(s.min=t),t>s.max&&(s.max=t)))}return s}_invalidateCacheForRow(t){const e=Math.floor(t.index/o);this._minMaxCache.forEach((t=>t.delete(e)))}_prepend(t){return(0,s.assert)(!this._shareRead,"collection should not be readonly"),(0,s.assert)(0!==t.length,"plotRows should not be empty"),this._invalidateSearchCaches(),this._minMaxCache.clear(),this._items=t.concat(this._items),this._start=0,this._end=this._items.length,t[0]}_append(t){return(0,s.assert)(!this._shareRead,"collection should not be readonly"),(0,s.assert)(0!==t.length,"plotRows should not be empty"),this._invalidateSearchCaches(),this._minMaxCache.clear(),this._items=this._items.concat(t),this._start=0,this._end=this._items.length,t[0]}_updateLast(t){(0,s.assert)(!this.isEmpty(),"plot list should not be empty");const e=this._items[this._end-1];(0,s.assert)(e.index===t.index,"last row index should match new row index"),this._invalidateCacheForRow(t),
this._invalidateSearchCaches(),this._items[this._end-1]=t}_merge(t){return(0,s.assert)(0!==t.length,"plot rows should not be empty"),this._invalidateSearchCaches(),this._minMaxCache.clear(),this._items=function(t,e){const i=function(t,e){const i=t.length,s=e.length;let n=i+s,r=0,a=0;for(;r<i&&a<s;)t[r].index<e[a].index?r++:t[r].index>e[a].index?a++:(r++,a++,n--);return n}(t,e),s=new Array(i);let n=0,r=0;const a=t.length,h=e.length;let l=0;for(;n<a&&r<h;)t[n].index<e[r].index?(s[l]=t[n],n++):t[n].index>e[r].index?(s[l]=e[r],r++):(s[l]=e[r],n++,r++),l++;for(;n<a;)s[l]=t[n],n++,l++;for(;r<h;)s[l]=e[r],r++,l++;return s}(this._items,t),this._start=0,this._end=this._items.length,t[0]}_minMaxOnRangeCachedImpl(t,e,i){if(this.isEmpty())return null;let n=null;const r=(0,s.ensureNotNull)(this.firstIndex()),a=(0,s.ensureNotNull)(this.lastIndex()),h=Math.max(t,r),l=Math.min(e,a),_=Math.ceil(h/o)*o,d=Math.max(_,Math.floor(l/o)*o);n=c(n,this._minMaxOnRange(h,Math.min(_,e,l),i));let u=this._minMaxCache.get(i);void 0===u&&(u=new Map,this._minMaxCache.set(i,u));for(let t=Math.max(_+1,h);t<d;t+=o){const e=Math.floor(t/o);let s=u.get(e);if(void 0===s){const t=e*o,n=(e+1)*o-1;s=this._minMaxOnRange(t,n,i),u.set(e,s)}n=c(n,s)}n=c(n,this._minMaxOnRange(d,l,i));return n}_minMaxOnRange(t,e,i){return this._plotMinMax(this._lowerbound(t,_),this._upperbound(e),i)}_rangeIteratorImpl(t,e){let i=t-1;return{[Symbol.iterator](){return this},next:()=>(i+=1,i>=e?{done:!0,value:void 0}:{done:!1,value:this._items[i]})}}_invalidateSearchCaches(){this._rowSearchCacheByIndex.clear(),this._rowSearchCacheByIndexWithoutEmptyValues.clear(),this._rowSearchCacheByTime.clear(),this._rowSearchCacheByTimeWithoutEmptyValues.clear()}}function c(t,e){if(null===t)return e;if(null===e)return t;return{min:Math.min(t.min,e.min),max:Math.max(t.max,e.max)}}}}]);